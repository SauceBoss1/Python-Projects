# -*- coding: utf-8 -*-
"""Homework_10_Expressions_as_Classes_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_1-vWADL3SoOgHSauVawFDAw9zLQV5oN

Before you turn this problem in, make sure everything runs as expected. First, **restart the kernel** (in the menubar, select Kernel$\rightarrow$Restart) and then **run all cells** (in the menubar, select Cell$\rightarrow$Run All).

Make sure you fill in any place that says `YOUR CODE HERE` or "YOUR ANSWER HERE", as well as your name and collaborators below:
"""

NAME = "Derfel Terciano"
COLLABORATORS = "None"

"""---

# Homework 10: Expressions as Classes

Copyright Luca de Alfaro, 2019-21. 
License: [CC-BY-NC-ND](https://creativecommons.org/licenses/by-nc-nd/4.0/).

## About This Homework

The homework consists of 9 questions, for a total of 69 points.

The instructions for working on homework assignments are available on Canvas; as a summary: 

* Write your code only where indicated via `#YOUR CODE HERE`.  If you write code in other places, it will be discarded during grading. 
* Do not add/remove cells. 
* The tests are implemented with `assert` statements: if they fail, you will see an error (a Python exception).  If you see no error, you can assume that they pass.  

Once you are done working on it, you can download the .ipynb and [submit it to this form](https://docs.google.com/forms/d/e/1FAIpQLSfuAjv9zfBmo-9hRpcoyWPDzxl3uy7gzv8CePJtcFbg0XP5NQ/viewform?usp=sf_link).  This homework is due at **11:59pm on Friday 11 February 2022**.

We will now describe a more sophisticated representation for an expression, based on a hierarchy of classes.  The class **Expr** is the generic class denoting an expression.  It is an _abstract_ class: only its subclasses will be instantiated.  For every operator, such as `+`, there will be a subclass, such as `Plus`.  Variables will correspond to a special subclass, called `V`.  Numerical constants will be just represented by numbers, and not by subclasses of `Expr`. 

## The `Expr` class

The `Expr` class implements the various [methods used to emulate numerical types](https://docs.python.org/3/reference/datamodel.html?#emulating-numeric-types), such as `__add__`, `__sub__`, and so forth.  In this way, we can build an expression simply by writing

    x = V()
    x * 3 / 2

In the above, `V()` creates a variable (an object of class `V`), and assigns it to `x`.  Then, 

    x * 3

will also be an expression, composed of a multiplication node, with children the variable in `x`, and `3`. 
The multiplication node is implemented via a subclass `Multiply` of `Expr`. 
To make this work, we will define the [`__mul__`](https://docs.python.org/3/reference/datamodel.html#object.__mul__) method of `Expr` so that it produces a `Multiply` object, with as children the two operands being multiplied. 

Similarly, 

    x * 3 / 2

will create an object of class `Divide`, with as left child the `Multiply` node for `x * 3`, and as right child, the number 2.  Thus, the [`__truediv__`](https://docs.python.org/3/reference/datamodel.html#object.__truediv__) method of `Expr` will create a `Divide` node. 

Expressions can be evaluated.  You can assign a value to variables either when you create them: 

    x = V(value=2)
    e = x * 3 / 2
    e.eval()

which yields `3`.  Or you can assign a value to a variable later: 

    x = V()
    e = x * 3 / 2

    x.assign(3)
    e.eval()

which again yields `3`.

## Benefits of class-based representation 

Compared with the representation of expressions seen in the previous chapter, this class-based representation offers several advantages.  

First, we can build expressions in a natural way as shown above, via the over-riding of the usual arithmetic operators.  

Second, if we introduce a new operator, all we need is provide the implementation of the new operator: we do not need to modify the shared code that traverses the tree, and add one more case to a long case-analysis.  In other words, the code is far more modular.  This may seem a small point, but if one were to extend the representation of expressions to involve tensors (matrices) and operations on tensors, as is done in the symbolic representation of expressions used in machine-learning, the number of operators could easily grow to a hundred or more, making a modular approach the only reasonable one. 

Third, it becomes possible to attach methods to the expression objects, and as we will see in the next chapter, this can be very useful to implement machine learning frameworks.  But later about that.

## Defining an expression class

We define an abstract class `Expr`, representing a generic expression.  This generic class has as subclasses the classes that represent the various operators, such as `Plus`, `Minus`, `Multiply`, as well as the variable class `V`.  Here is our basic implementation.
"""

class Expr(object):
    """Abstract class representing expressions"""

    name = "expr" # Not used, but just to define it.

    def __init__(self, *args):
        """An object is created by passing to the constructor the children"""
        self.children = args
        self.value = None # The value of the expression
        self.child_values = None # The values of the children; useful to have

    def eval(self):
        """Evaluates the expression."""
        # First, we evaluate the children.
        self.child_values = [c.eval() if isinstance(c, Expr) else c
                             for c in self.children]
        # Then, we evaluate the expression itself.
        self.value = self.op(*self.child_values)
        return self.value

    def op(self):
        """This operator must be implemented in subclasses; it should
        compute self.value from self.values, thus implementing the
        operator at the expression node."""
        raise NotImplementedError()

    def __repr__(self):
        """Represents the expression in a somewhat readable way."""
        if len(self.children) == 1:
            # Unary operators
            return "({}{})".format(self.__class__.name, self.children[0])
        elif len(self.children) == 2:
            return "({} {} {})".format(
                self.children[0], self.__class__.name, self.children[1]
            )
        # Catch-all.
        return "{}({})".format(self.__class__.__name__,
                                ', '.join(repr(c) for c in self.children))

    # Expression constructors

    def __add__(self, other):
        return Plus(self, other)

    def __radd__(self, other):
        return Plus(self, other)

    def __sub__(self, other):
        return Minus(self, other)

    def __rsub__(self, other):
        return Minus(other, self)

    def __mul__(self, other):
        return Multiply(self, other)

    def __rmul__(self, other):
        return Multiply(other, self)

    def __truediv__(self, other):
        return Divide(self, other)

    def __rtruediv__(self, other):
        return Divide(other, self)

    def __neg__(self):
        return Negative(self)

"""Variables are created specifying a name, and an initial value.  If nothing is specified, variables have random initial values.  You can assign a value to a variable using the `assign` method.  The `eval` method of a variable simply returns its value. """

import random
import string

class V(Expr):
    """Variable."""

    def __init__(self, value=None):
        super().__init__()
        self.children = []
        self.value = random.gauss(0, 1) if value is None else value
        self.name = ''.join(
            random.choices(string.ascii_letters + string.digits, k=3))

    def eval(self):
        return self.value

    def assign(self, value):
        self.value = value

    def __repr__(self):
        return "V({}, value={})".format(self.name, self.value)

"""Here are the constructors for the other operators; for them, we just need to provide an implementation for `op`, since all the rest is inherited from `Expr`.  We actually also define a name, as a class attribute, that we use in the representation method."""

class Plus(Expr):
    name = "+"
    def op(self, x, y):
        return x + y

class Minus(Expr):
    name = "-"
    def op(self, x, y):
        return x - y

class Multiply(Expr):
    name = "*"
    def op(self, x, y):
        return x * y

class Divide(Expr):
    name = "/"
    def op(self, x, y):
        return x / y

class Negative(Expr):
    name = "-"
    def op(self, x):
        return -x

"""We can build and evaluate expressions quite simply."""

"""### Defining Expression Equality

If we test equality between expressions, we are in for a surprise.
"""

x = V()
e1 = x + 4
e2 = x + 4
e1 == e2

"""Why is the result False? 

Python knows how to compare objects that belong to its own types.  So you can do comparisons between strings, numbers, tuples, and more, and it all works as expected.  This is why we could check equality of expressions represented as trees: those expression trees are composed entirely of standard Python types, namely, strings, numbers, and tuples. 

However, `Expr`, `V`, etc, are classes we defined, and Python has no idea of what it means for objects of user-defined classes to be equal.  
In this case, Python defaults to considering equal two objects if they are the _same_ object. 
The two expressions _e1_ and _e2_ above are not the same object: they are two distinct objects, which just happen to represent the same expression. 

If we want to have a notion of expression equality that represents our idea that "two expression objects are equal if they represent the same expression", we need to define equality ourselves. 
This can be easily done, by defining an _ _ eq _ _ method.  This method [has the form](https://docs.python.org/3/reference/datamodel.html#object.__eq__):

    def __eq__(self, other):
        ...
        return <True/False>
        
Here, self is the object on which the method is called, and other is another object -- any other object.  Our job is to define when the object self is equal to the object other.  This can be easily done; using again our way of adding methods to existing classes, we write:
"""

def expr_eq(self, other):
    if isinstance(other, Expr):
        # The operators have to be the same
        if self.__class__ != other.__class__:
            return False
        # and their corresponding children need to be equal
        if len(self.children) != len(other.children):
            return False
        for c1, c2 in zip(self.children, other.children):
            if c1 != c2: return False
        return True
    else:
        return False

Expr.__eq__ = expr_eq

"""If we did not define equality for variables, two variables would be considered equal according to `Expr.__eq__`, since `V` is a subclass of `Expr`.  This would yield non-intended consequences (all variables would be considered equal).

Thus, we define equality for variables to be the basic equality for objects: two variables are equal iff they are the same object.  In the definition below, `object.__eq__` is this primitive notion of equality, defined over the class `object` of Python, which is the base class for all classes. 

"""

V.__eq__  = object.__eq__

"""Once expression equality is thus defined, we get the expected result when we compare expressions:"""

x = V()
e1 = x + 4
e2 = x + 4
e1 == e2

"""Having to define equality "by hand" is very pedantic, but it does give us the flexibility of defining precisely what it means for two expressions to be equal.

## Variable Occurrence

Now that we have expressions, let us play with them.  First, as a warm-up exercise, let us write an `occurs` method for expressions, which checks if a given variable occurs in the expression.  First we define it for a variable: of course, a variable occurs in itself only if the variable is the same as the one whose occurrence we are checking.

## Question 1: Variable occurrence in variables
"""

### Variable occurrence in a variable

def v_contains(self, var):
    """Returns True of var is the same as self, and False otherwise."""
    # YOUR CODE HERE
    return self == var

V.__contains__ = v_contains

## Here you can also test your code.
### Tests for variable occurrence

x = V()
y = V()
assert x in x
assert not x in y
z = x
assert x in z

"""## Question 2: Occurrence of a variable in an expression

Once we define occurrence of a variable in a variable, we can define occurrence in a variable in a general expression. Of course, a variable appears in an expression if it appears in some of its children.  
"""

### Occurrence of a variable in an expression

def expr_contains(self, var):
    # YOUR CODE HERE
    for child in self.children:
      if isinstance(child, Expr) and var in child:
        return True

Expr.__contains__ = expr_contains

## Here you can also test your code.

## Tests for occurrence: 5 points.

x = V()
y = V()
z = V()
e = x + (2 * y)

assert x in e
assert y in e
assert z not in e

## Hidden tests for occurrence: 5 points.

"""## Variable Substitution

Another fun thing we can do is substitute a variable with an expression.  Suppose you define an expression: 

    x = V()
    y = V()
    e = (x + 1) * (y + 1)

Suppose you also have another expression: 

    z = V()
    f = y + z

Then, you can replace all occurrences of variable `x` in `e` with expression `f`: 

    new_e = e.replace(x, f)

and `new_e` should be then equal to: 

    ((x + z) + 1) * (y + 1)

Let us implement variable substitution.  Let us begin by defining variable substitution for variables.

## Question 3: Variable replacement for variables
"""

### Variable replacement in variables

def v_replace(self, x, e):
    """If self is x, replaces all occurrences of x with e."""
    # YOUR CODE HERE
    if x in self:
      self = e
    return self

V.replace = v_replace

## Here you can also test your code

x = V()
y = V()
z = V()

## Tests for variable replacement in variables. 2 points.
x = V()
y = V()
z = V()
assert x == x.replace(x, x)
assert y == x.replace(x, y)
assert x == x.replace(y, z)
assert x.replace(x, y).replace(y, z) == z

## Other tests for variable replacement. 2 points.

x = V()
y = V()

e = x.replace(x, y + 3 * x)

x.assign(2)
y.assign(3)
assert e.eval() == 9

## Hidden tests for variable replacement.  2 points.

"""We now define variable replacement for expressions. Consider a simple expression:"""

x = V()
y = V()
z = V()
e = x + y

"""Suppose we want to return `e.replace(x, z)`.  The idea is: 

* carry out the replacement for each child (via a recursive call, as usual),  
* then return an expression built out of the replacements. 

For instance, consider `e = x + y`.  To compute 

    e.replace(x, z)

we first replace `x` with `z`, and then we return `Plus(z, y)`. 

The problem is exactly in the last sentence.  A `Plus` object, after carrying out the replacement in the children, should return a `Plus` object with the new children.  Similarly, a `Minus` object should return a `Minus` object, a `Multiply` object should return a `Multiply` object, and so forth.  If we implement this in the straightforward way, we need to add a `replace` method to all of these classes, so that they can return an object of the appropriate type.   This is a lot of work. 

Is there a better way?  It turns out, yes.  In an object, 

    self.__class__

is the class of the object.  So if you want to return a new object of the same class, created say with arguments `x` and `y`, all you need to do is: 

    self.__class__(x, y)

In this way, if you are in a `Plus` object, `self.__class__` is `Plus`, and everything works. 
Using this idea, we, that is, you, can implement the replacement method directly for the `Expr` class.

## Question 4: Replacement for expressions
"""

### Replacement for expressions
print('\nq4')
def expr_replace(self, x, e):
    # YOUR CODE HERE
    for child in self.children:
      if isinstance(child, Expr) and x in child and not isinstance(child, V):
        cc = expr_replace(child, x, e)
        print(cc)
        x = e
        
      else:
        return child

Expr.replace = expr_replace

### Here you can debug your code.

x = V()
y = V()
z = V()

e = (1 + x) * (1 + y)
print('e:',e)
f = e.replace(x, x + z)
print(f)
